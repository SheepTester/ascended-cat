<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Ascended Cat blocks playground</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
    <!-- <link rel="stylesheet" type="text/css" href="/sheep3.css"> -->
    <link rel="stylesheet" href="./blocks.css">

    <!-- <script src="/sheep3.js" charset="utf-8"></script> -->
    <script src="../utils/elem.js" charset="utf-8"></script>
    <script src="./constants.js" charset="utf-8"></script>
    <script src="./component.js" charset="utf-8"></script>
    <script src="./input.js" charset="utf-8"></script>
    <script src="./block.js" charset="utf-8"></script>
    <script src="./scripts.js" charset="utf-8"></script>
    <script src="./workspace.js" charset="utf-8"></script>
    <script src="./blocks.js" charset="utf-8"></script>

    <style>
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-size: 0;
        overflow: none;
        display: flex;
        background-color: #222;
        color: white;
      }

      #palette {
        width: 200px;
        flex: none;
        position: relative;
        background-color: #282828;
      }
      #scripts {
        flex: auto;
        position: relative;
      }

      .block-back {
        stroke: rgba(0, 0, 0, 0.2);
      }
      .block-category-nonexistent {
        --colour: red;
      }
      .block-category-test {
        --colour: #6AB6BC;
      }
      .block-category-motion {
        --colour: #6A92BC;
      }

      .block-text-component,
      .block-input {
        font-family: 'Lato', sans-serif;
      }
      .block-block {
        cursor: grab;
      }
      .block-block > .block-text-component {
        text-shadow: 0 0 2px black;
        font-size: 12px;
        fill: white;
      }
      .block-string-input:not(.block-input-has-block),
      .block-number-input:not(.block-input-has-block) {
        cursor: text;
      }
      .block-string-input > .block-input-back,
      .block-number-input > .block-input-back {
        stroke: rgba(0, 0, 0, 0.2);
        fill: white;
      }
      .block-input-value,
      .block-input {
        font-size: 10px;
        fill: #222;
        color: #222;
      }
      .block-boolean-input > .block-input-back {
        fill: rgba(0, 0, 0, 0.1);
        stroke: rgba(0, 0, 0, 0.2);
      }
      .block-boolean-input > .block-input-value {
        visibility: hidden;
      }
      .block-input:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
      }
      .block-string-input {
        padding: 2px 4px;
      }
      .block-number-input {
        padding: 2px 4px;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <div id="palette"></div>
    <div id="scripts"></div>
    <script>
const blocks = new Blocks([
  {
    id: 'test',
    name: 'Test',
    blocks: [
      {
        opcode: 'test',
        blockType: Blocks.BlockType.COMMAND,
        text: 'wow wow long long hat hat',
        hat: true
      },
      {
        opcode: 'branch',
        blockType: Blocks.BlockType.COMMAND,
        text: 'branchu [WOW]: [B1] or [B2]',
        terminal: true,
        arguments: {
          WOW: {
            type: Blocks.ArgumentType.STRING,
            default: 'Hmm!'
          },
          B1: {
            type: Blocks.ArgumentType.BRANCH
          },
          B2: {
            type: Blocks.ArgumentType.BRANCH
          }
        }
      },
      {
        opcode: 'join',
        blockType: Blocks.BlockType.REPORTER,
        text: 'join [A] [B]',
        arguments: {
          A: {
            type: Blocks.ArgumentType.STRING,
            default: 'Hello '
          },
          B: {
            type: Blocks.ArgumentType.STRING,
            default: 'world!'
          }
        }
      },
      {
        opcode: 'add',
        blockType: Blocks.BlockType.REPORTER,
        text: '[A] + [B]',
        arguments: {
          A: {
            type: Blocks.ArgumentType.NUMBER
          },
          B: {
            type: Blocks.ArgumentType.NUMBER
          }
        }
      },
      {
        opcode: 'not',
        blockType: Blocks.BlockType.BOOLEAN,
        text: 'not [TEST]',
        arguments: {
          TEST: {
            type: Blocks.ArgumentType.BOOLEAN
          }
        }
      }
    ]
  }
])
// Add categories
blocks.addCategory({
  id: 'motion',
  name: 'Motion',
  blocks: [
    {
      opcode: 'moveSteps',
      blockType: Blocks.BlockType.COMMAND,
      // branchCount, terminal, (hat?)
      text: 'move [STEPS] steps',
      arguments: {
        STEPS: {
          type: Blocks.ArgumentType.NUMBER,
          default: 10
        }
      }
      // func, filter
    },
    {
      opcode: 'goTo',
      blockType: Blocks.BlockType.COMMAND,
      text: 'go to x: [X] y: [Y] z: [Z]',
      arguments: {
        X: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0 // TODO: Set from current position somehow
        },
        Y: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        },
        Z: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        }
      }
    },
    {
      opcode: 'glideTo',
      blockType: Blocks.BlockType.COMMAND,
      text: 'glide [TIME] secs to x: [X] y: [Y] z: [Z]',
      arguments: {
        TIME: {
          type: Blocks.ArgumentType.NUMBER,
          default: 1
        },
        X: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        },
        Y: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        },
        Z: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        }
      }
    },
    '---', // Separator
    {
      opcode: 'pointInDirection',
      blockType: Blocks.BlockType.COMMAND,
      text: 'point in direction [ROT_Y] [ROT_X] [ROT_Z]',
      arguments: {
        ROT_X: {
          type: Blocks.ArgumentType.ANGLE,
          default: 0
        },
        ROT_Y: {
          type: Blocks.ArgumentType.ANGLE,
          default: 0
        },
        ROT_Z: {
          type: Blocks.ArgumentType.ANGLE,
          default: 0
        }
      }
    }
  ],
  translationMap: {
    xl: {
      '__name__': 'Moc',
      'moveSteps': 'mov [STEPS] pases',
      'goTo': 'ir a x: [X] y: [Y] z: [Z]',
      'glideTo': 'slid durant [TIME] sex a x: [X] y: [Y] z: [Z]'
    }
  }
})

const palette = blocks.createPaletteWorkspace(document.getElementById('palette'))
const scripts = blocks.createWorkspace(document.getElementById('scripts'))

const stack = blocks.createScript([
  blocks.createBlock('test.test'),
  blocks.createBlock('nonexistent.test'),
  blocks.createBlock('test.nonexistent'),
  blocks.createBlock('motion.test'),
  blocks.createBlock('test.branch', {
    WOW: blocks.createBlock('test.join', {
      A: blocks.createBlock('test.add'),
      B: blocks.createBlock('test.join')
    }),
    B1: [
      blocks.createBlock('motion.moveSteps', {
        STEPS: blocks.createBlock('test.not')
      }),
      blocks.createBlock('motion.moveSteps')
    ]
  })
])
stack.setPosition(10, 30)
scripts.add(stack)
window.requestAnimationFrame(() => {
  blocks.updateRects()
  stack.resize()
})
    </script>
  </body>
</html>
