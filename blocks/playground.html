<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Ascended Cat blocks playground</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <link rel="stylesheet" href="./blocks.css">

    <script src="/sheep3.js" charset="utf-8"></script>

    <style>
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-size: 0;
        overflow: hidden;
        display: flex;
        background-color: black;
        color: white;
      }

      #controls button {
        cursor: pointer;
      }
      #palette {
        width: 200px;
        flex: none;
        position: relative;
        background-color: #282828;
      }
      #scripts {
        flex: auto;
        position: relative;
        background-color: #222;
      }

      .block-back {
        stroke: rgba(0, 0, 0, 0.2);
      }
      [data-category="nonexistent"] {
        --colour: red;
      }
      [data-category="test"] {
        --colour: #6AB6BC;
      }
      [data-category="motion"] {
        --colour: #6A92BC;
      }
      [data-category="control"] {
        --colour: #bdb16a;
      }
      [data-category="operators"] {
        --colour: #6ABC88;
      }

      .block-text-component,
      .block-input {
        font-family: 'Lato', sans-serif;
      }
      .block-block {
        cursor: grab;
      }
      .block-block > .block-text-component {
        text-shadow: 0 0 2px black;
        font-size: 12px;
        fill: white;
      }
      .block-string-input:not(.block-input-has-block),
      .block-number-input:not(.block-input-has-block) {
        cursor: text;
      }
      .block-string-input > .block-input-back,
      .block-number-input > .block-input-back {
        stroke: rgba(0, 0, 0, 0.2);
        fill: white;
      }
      .block-input-value,
      .block-input {
        font-size: 10px;
        fill: #222;
        color: #222;
      }
      .block-boolean-input > .block-input-back {
        fill: rgba(0, 0, 0, 0.1);
        stroke: rgba(0, 0, 0, 0.2);
      }
      .block-boolean-input > .block-input-value {
        visibility: hidden;
      }
      .block-input:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
      }
      .block-string-input {
        padding: 2px 4px;
      }
      .block-number-input {
        padding: 2px 4px;
        border-radius: 10px;
      }

      .block-category-header .block-text-component {
        fill: var(--colour);
        font-size: 14px;
      }
      .block-category-header-line {
        stroke: rgba(255, 255, 255, 0.3);
        stroke-width: 1.5;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <button id="toggle-lang">Toggle language</button><br>
      <button id="sprinkles">Sprinkles!</button><br>
      <button id="spaghetti">Spaghetti!</button>
    </div>
    <div id="palette"></div>
    <div id="scripts"></div>
    <script type="module">
import {Blocks} from './blocks.js'

const specA = {
  id: 'test',
  name: 'Test',
  blocks: [
    {
      opcode: 'test',
      blockType: Blocks.BlockType.COMMAND,
      text: 'wow wow long long hat hat',
      hat: true
    },
    {
      opcode: 'branch',
      blockType: Blocks.BlockType.COMMAND,
      text: 'branchu [WOW]: [B1] or [B2]',
      terminal: true,
      arguments: {
        WOW: {
          type: Blocks.ArgumentType.STRING,
          default: 'Hmm!'
        },
        B1: {
          type: Blocks.ArgumentType.BRANCH
        },
        B2: {
          type: Blocks.ArgumentType.BRANCH
        }
      }
    },
    {
      opcode: 'join',
      blockType: Blocks.BlockType.REPORTER,
      text: 'join [A] [B]',
      arguments: {
        A: {
          type: Blocks.ArgumentType.STRING,
          default: 'Hello '
        },
        B: {
          type: Blocks.ArgumentType.STRING,
          default: 'world!'
        }
      }
    },
    {
      opcode: 'add',
      blockType: Blocks.BlockType.REPORTER,
      text: '[A] + [B]',
      arguments: {
        A: {
          type: Blocks.ArgumentType.NUMBER
        },
        B: {
          type: Blocks.ArgumentType.NUMBER
        }
      }
    },
    {
      opcode: 'not',
      blockType: Blocks.BlockType.BOOLEAN,
      text: 'not [TEST]',
      arguments: {
        TEST: {
          type: Blocks.ArgumentType.BOOLEAN
        }
      }
    },
    {
      opcode: 'repeatUntil',
      blockType: Blocks.BlockType.COMMAND,
      text: 'repeat until [CONDITION][LOOP]',
      arguments: {
        CONDITION: {
          type: Blocks.ArgumentType.BOOLEAN
        },
        LOOP: {
          type: Blocks.ArgumentType.BRANCH
        }
      }
    }
  ],
  translationMap: {
    xl: {
      '__name__': '!sgo8iu Ñsdf e è dsfg u ondu   .',
      'repeatUntil': 'hato [LOOP] et [CONDITION]',
      'not': '[TEST]n\'t',
      'add': '+ [A] [B]',
      'join': '+ [B] [A]',
      'join.A_default': 'Ooogoo',
      'join.B_default': '\\',
      'branch': 'dsfug idsfg [B2] [WOW] [B1]',
      'test': '.'
    }
  }
}
const specB = {
  id: 'motion',
  name: 'Motion',
  blocks: [
    {
      opcode: 'moveSteps',
      blockType: Blocks.BlockType.COMMAND,
      // branchCount, terminal, (hat?)
      text: 'move [STEPS] steps',
      arguments: {
        STEPS: {
          type: Blocks.ArgumentType.NUMBER,
          default: 10
        }
      }
      // func, filter
    },
    {
      opcode: 'goTo',
      blockType: Blocks.BlockType.COMMAND,
      text: 'go to x: [X] y: [Y] z: [Z]',
      arguments: {
        X: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0 // TODO: Set from current position somehow
        },
        Y: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        },
        Z: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        }
      }
    },
    {
      opcode: 'glideTo',
      blockType: Blocks.BlockType.COMMAND,
      text: 'glide [TIME] secs to x: [X] y: [Y] z: [Z]',
      arguments: {
        TIME: {
          type: Blocks.ArgumentType.NUMBER,
          default: 1
        },
        X: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        },
        Y: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        },
        Z: {
          type: Blocks.ArgumentType.NUMBER,
          default: 0
        }
      }
    },
    '---', // Separator
    {
      opcode: 'pointInDirection',
      blockType: Blocks.BlockType.COMMAND,
      text: 'point in direction [ROT_Y] [ROT_X] [ROT_Z]',
      arguments: {
        ROT_X: {
          type: Blocks.ArgumentType.ANGLE,
          default: 0
        },
        ROT_Y: {
          type: Blocks.ArgumentType.ANGLE,
          default: 0
        },
        ROT_Z: {
          type: Blocks.ArgumentType.ANGLE,
          default: 0
        }
      }
    }
  ],
  translationMap: {
    xl: {
      '__name__': 'Moc',
      'moveSteps': 'mov [STEPS] pases',
      'goTo': 'ir a x: [X] y: [Y] z: [Z]',
      'glideTo': 'slid durant [TIME] s a x: [X] y: [Y] z: [Z]'
    }
  }
}
const specC = {
  id: 'control',
  name: 'Control',
  blocks: [
    {
      opcode: 'if',
      blockType: Blocks.BlockType.COMMAND,
      text: 'if [CONDITION] then[CHOICE_A]',
      arguments: {
        CONDITION: {
          type: Blocks.ArgumentType.BOOLEAN
        },
        CHOICE_A: {
          type: Blocks.ArgumentType.BRANCH
        }
      }
    },
    {
      opcode: 'ifElse',
      blockType: Blocks.BlockType.COMMAND,
      text: 'if [CONDITION] then[CHOICE_A]else[CHOICE_B]',
      arguments: {
        CONDITION: {
          type: Blocks.ArgumentType.BOOLEAN
        },
        CHOICE_A: {
          type: Blocks.ArgumentType.BRANCH
        },
        CHOICE_B: {
          type: Blocks.ArgumentType.BRANCH
        }
      }
    }
  ]
}
const specD = {
  id: 'operators',
  name: 'Operators',
  blocks: [
    {
      opcode: 'equals',
      blockType: Blocks.BlockType.BOOLEAN,
      text: '[A] = [B]',
      arguments: {
        A: {
          type: Blocks.ArgumentType.STRING,
          default: ''
        },
        B: {
          type: Blocks.ArgumentType.STRING,
          default: ''
        }
      }
    },
    {
      opcode: 'strictlyEquals',
      blockType: Blocks.BlockType.BOOLEAN,
      text: 'is [A] exactly [B]?',
      arguments: {
        A: {
          type: Blocks.ArgumentType.STRING,
          default: 'apple'
        },
        B: {
          type: Blocks.ArgumentType.STRING,
          default: 'APPLE'
        }
      }
    }
  ]
}

const blocks = new Blocks([specA])
// Add categories
blocks.addCategory(specB)
blocks.addCategory(specC)
blocks.addCategory(specD)

const palette = blocks.createPaletteWorkspace(document.getElementById('palette'), [specB])
palette.blockOrder.push(specC, specD)
palette.updateBlockOrder().filter()

const scripts = blocks.createScriptsWorkspace(document.getElementById('scripts'))

const stack = blocks.createScript([
  blocks.createBlock('test.test'),
  blocks.createBlock('test.branch', {
    WOW: blocks.createBlock('test.join', {
      A: blocks.createBlock('test.add'),
      B: blocks.createBlock('test.join')
    }),
    B1: [
      blocks.createBlock('motion.moveSteps', {
        STEPS: blocks.createBlock('test.not')
      }),
      blocks.createBlock('motion.moveSteps')
    ]
  })
])
stack.setPosition(10, 30)
scripts.add(stack)
window.requestAnimationFrame(() => {
  blocks.updateRects()
  stack.resize()
})
window.addEventListener('resize', e => {
  blocks.updateRects()
})

document.getElementById('toggle-lang').addEventListener('click', e => {
  if (blocks.language === 'xl') {
    blocks.setLanguage()
  } else {
    blocks.setLanguage('xl')
  }
  palette.updateBlockOrder().filter()
})

// Based on scratch-blocks:
// https://sheeptester.github.io/scratch-blocks/playgrounds/tests/vertical_playground.html
document.getElementById('sprinkles').addEventListener('click', e => {
  const count = 100
  const allOpcodes = Object.entries(blocks.categories)
    .map(([id, blocks]) => Object.keys(blocks).map(opcode => `${id}.${opcode}`))
    .flat()
  console.time('Sprinkles: Adding to DOM (no resizing)')
  for (let i = 0; i < count; i++) {
    const script = blocks.createScript([
      blocks.createBlock(allOpcodes[Math.random() * allOpcodes.length | 0])
    ])
    script.setPosition(
      Math.round(Math.random() * 450 + 40),
      Math.round(Math.random() * 600 + 40)
    )
    scripts.add(script)
    script.resize()
  }
  console.timeEnd('Sprinkles: Adding to DOM (no resizing)')
})
document.getElementById('spaghetti').addEventListener('click', e => {
  const depth = 3
  const equalsJSON = JSON.stringify({
    opcode: 'operators.equals',
    params: { A: 'foo', B: 'REPLACE_EQ' }
  })
  const ifElseJSON = JSON.stringify({
    opcode: 'control.ifElse',
    params: { CONDITION: 'REPLACE_COND', CHOICE_A: 'REPLACE_!', CHOICE_B: 'REPLACE_!' }
  })
  let json = `[${ifElseJSON},"NEXT"]`
  // Nest if-elses
  for (let i = 0; i < depth * 2; i++) {
    json = json.replace(/"REPLACE_!"/g, `[${ifElseJSON},"NEXT"]`)
  }
  // Add more blocks to the end of each
  for (let i = 0; i < depth; i++) {
    json = json.replace(/"NEXT"/g, `${ifElseJSON},"NEXT"`)
  }
  // Nest equals
  let equals = equalsJSON
  for (let i = 0; i < depth; i++) {
    equals = equals.replace(/"REPLACE_EQ"/g, equalsJSON)
  }
  // Insert equals
  json = json.replace(/"REPLACE_COND"/g, equals)
    // Remove leftover placeholders
    .replace(/"REPLACE_!"/g, '[]')
    .replace(/,?"NEXT"/g, '')
    .replace(/"REPLACE_EQ"/g, '""')
  console.time('Spaghetti: Adding to DOM (no resizing)')
  const script = blocks.scriptFromJSON({
    x: 0,
    y: 0,
    blocks: JSON.parse(json)
  })
  scripts.add(script)
  console.timeEnd('Spaghetti: Adding to DOM (no resizing)')
  console.time('Spaghetti: Resizing')
  script.resize()
    .then(() => {
      console.timeEnd('Spaghetti: Resizing')
    })
})

window.scripts = scripts
    </script>
  </body>
</html>
